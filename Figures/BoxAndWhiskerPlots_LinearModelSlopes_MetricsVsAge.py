import os, sys, csv, mysql.connector, datetime, matplotlib, time
from scipy import stats
import numpy as np
matplotlib.use('agg')
import matplotlib.pyplot as plt

'''

Author : Sara Willis
Date   : March 20, 2019
-----------------------


------------------------------------------- Dependencies -------------------------------------------

 Python
-------

The user will need Python3 to run this script with the following non-standard Python dependencies:
 
   * matplotlib       -- https://anaconda.org/conda-forge/matplotlib

   * mysql.connector -- https://anaconda.org/anaconda/mysql-connector-python

 MySQL
-------

The user will  need access to the relevant MySQL database

   R
-------

The user will need R installed and will need to specify the command that calls RScript. The command R will not work
to run the R script that is generated by this program


---------------------------------------------- About ----------------------------------------------

Figures
------------
This script is designed to generate box and whiskers plots either for full genes or pfam domains metrics vs. time.
This is done by collecting all proteins or domains, sorting them either by a homology group ID 
or by pfam ID, taking the average of all data points in a particular grouping, and creating a
data frame for all datapoints vs. their age. The data are either then normalized using a box-cox
transformation or not (this depends on the user input) and a linear regression is performed.
The linear regression and a loess regression are plotted as an overlay on the box and whisker plot

Slope Files
------------
If the user wants to create a csv file that contains the slope(s) and standard error(s) of a particular metric vs time, they can
us the input option "slopes". For things like ISD, Aggregation Propensity, etc... this will only generate a single row, however, 
if the user is looking at amino acid composition for multiple amino acids, the slopes for all amino acids analyze will be stored
in the same CSV file.

Both Options
------------
This script allows the user to enter various options to customize the dataset they are interested in.
They may choose the kingdom, the transmembrane status, domains vs. proteins, etc. that they want to analyze.
All options are listed for the user below.


Note: order is not important for the command-line arguments


---------------------------------------------- Usage ----------------------------------------------



Usage             :  python3 ScriptName.py pfam|fullgene metric=<x> [test] [speciesuid=<n>] [kingdom=<x>] [transformed] 
                                                                    [transmembrane=<x>] [xlim=xmin,xmax] [ylim=ymin,ymax] 
                                                                    [aa=<x>] [slopes] [eukaryotespecific] [lambda[=<x>]]



--------------------------------------------- Options ----------------------------------------------



pfam|fullgene     :  (required) pfam or fullgene. Specifies which dataset used to generate slopes
                       
metric=<x>        :  (required) Specifies which metric will be plotted
                                                  
test              :  if included, only extracts first 1000 columns from each data table. For use with testing and debugging

speciesuid=n      :  Amino acid slopes for species with species UID n (found in SpeciesList MySQL table)
                
kingdom=x         :  Amino acid slopes for designated kingdom 
                                                          
transformed       :  Uses Box-Cox transform to normalize dataset before computing slope                                  
                    By default, if this argument is not included, the data will not be transformed
                     
transmembrane=x   :  When not included as an argument, all data points are included.                                     
                     When x=true, only includes transmembrane proteins/domains                                           
                     When x=false, only includes proteins/domains predicted to not be transmembrane
                         
xlim=xmin,xmax    :  Configures the x limits of the R plot.
                                                              
ylim=ymin,ymax    :  Configures the y limits of the R plot.

                     
aa=<x>            :  Chooses the amino acid(s) to be analyze. For all amino acids, use "all" or leave blank              
                    Otherwise use a comma-delimited string to select a subset. e.g. aa=V,L,F,M

slopes            :  Prints a csv file with linear regression slopes instead of producing a figure

eukaryotespecific : Selects only pfams flagged as eukaryote specific


lambda=<x>        : Including the argument lambda writes to a file the value used to transform the data. This
                    only works if the user has selected the "slopes" option. If the user includes a value, then
                    the script uses that value to transform the data instead of finding the optimal value 
                                                            
-------------
Domain Options    :  ISD, DensityOfAPRs, DensityOfAAsInAPRs, Clustering_Trunc, Clustering_AllFrames, Length, AAComp
     
Kingdom Options   :  invertebrate, vertebrate, plant, fungi, animal

                                                            
Metric Options    :  ISD, DensityOfAPRs, DensityOfAAsInAPRs, Length, AAComp

                                            
---------------------------------------- Data Transformation ---------------------------------------



A note about transforming the data:

Because Box-Cox transforms require values to be greater than zero, if the data are transformed, the value 0.5
is added to each data point. The reason this is required is because in some cases domains or proteins may be 
too short to include all amino acids and so sometimes the percent composition for a particular domain/protein
homology group is zero. If a particular metric is dependent on the length of the protein (i.e. Density of APRs
or AA Composition) 0.5 is added to the numerator. Because the extracted metrics have all been divided by the
protein/domain length prior to extraction, this is achieved by adding 0.5\length to the metric




'''


##########################################################################################
#                                   User-Specific Data                                   #
##########################################################################################


# User's MySQL Connection Information
Database = ''
User = ''
Host = ''
Password = ''

# Where the unique protein UIDs are stored (i.e., where there has been a filtering process
# reducing the number of transcripts for each gene to 1)
NCBIUniqueProteinTable        = 'UniqueProteinGenePairs_Table_NCBI'
EnsemblUniqueProteinTable     = 'UniqueProteinGenePairs_Table_Ensembl'


# Full Protein Data Tables
EnsemblProteinDataTable       = 'Genomes_Multicellular_ProteinMetrics'
NCBIProteinDataTable          = 'NCBIGenomes_ProteinMetrics_Complete'
UniqueProteinTableUID         = 'UID'        

AgeColumn                     = 'AgeOfOldestPfam_LUCA_LECA_Updated'
FullGeneMetricColumn          = 'MeanISD_IUPred2_WithCys'
FilterColumn                  = 'PassedIUPredFilters'
HomologyGroupIDColumn         = 'HomologyGroupID'
TransmembraneColumn           = 'ExpAA'
UIDColumn                     = 'ProteinTableUID'
FullGeneSpeciesUIDColumn      = 'SpeciesUID'
ProteinLengthColumn           = 'ProteinLength'
DeltaTangoColumn_APR          = 'DeltaTango_DensityOfAggProneRegions'
DeltaTangoColumn_AAAPR        = 'DeltaTango_DensityOfAAsInAPRs'
DeltaISDColumn                = 'DeltaISD_IUPred2_WithCys'

# Pfam Data Tables
EnsemblPfamDataTable          = 'Genomes_Multicellular_DomainMetrics'
NCBIPfamDataTable             = 'NCBIGenomes_DomainMetrics_Complete'
PfamDataTableUIDColumn        = 'UID'
PfamDataTableMetricColumn     = 'MeanISD_IUPred2_WithCys'
PfamDataTableFilterColumn     = 'PassedIUPredFilters'
PfamDataTableProteinUIDColumn = 'ProteinTableUID'
PfamSpeciesUIDColumn          = 'SpeciesUID'
PfamDataTablePfamUIDColumn    = 'PfamUID'
DomainLengthColumn            = 'DomainLength'
DomainTransmembraneColumn     = 'TmhmmTopology'

# NOTE: This is for *domains only*
# This is the minimum fractional score a domain needs to have to be counted as transmembrane.
# See script "AssignTransmembraneStatus_Domains.py" in the Metrics directory to determine how
# this value is calculated. Roughly speaking, it's the percentage of overlap between a domain
# and a tmhmm-predicted helix.
TransmembraneThresholdCutoff  = 0.5

# Pfam UID Table
PfamUIDTable                  = 'PfamUIDsTable_EnsemblAndNCBI'
PfamUIDColumn                 = 'PfamUID'
PfamAgeColumn                 = 'Age_Oldest_MY'
EukaryoteSpecificColumn       = 'EukaryoteSpecific'

# Species Table
SpeciesTable                  = 'SpeciesList'
SpeciesUIDColumn              = 'SpeciesUID'
KingdomColumn                 = 'Kingdom'

# User's path to their R 'Rscript' executable (Rscript specifically, not the executable R)
RunRCommand                   = '~/R-3.5.2/bin/Rscript'

# How chatty the user wants the program to be 
Verbose = True

# If Very Verbose is set to True, the files generated by this script that are typically deleted
# are retained for debugging purposes
VeryVerbose = False

# If the user wants to customize this script to get more metrics that can be plotted, add the metric to the
# following dictionary. The general format is:
# {command-line metric name: [MySQL Column Name for Metric, Plot label for metric]}
MetricOptions = {'isd': ['MeanISD_IUPred2_WithCys', 'Mean ISD'],
                 'densityofaprs': ['DensityOfAggProneRegions','Density of Aggregation-Prone Regions'],
                 'densityofaasinaprs': ['DensityOfAAsInAPRs',"Density of AAs in APRs"],
                 'clustering_trunc': ['NormalizedIndexOfDispersion_Trunc_FILVM', 'Clustering'],
                 'clustering_allframes': ['NormalizedIndexOfDispersion_AllPhases_FILVM','Clustering (All Frames, FILVM)'],
                 'proteinlength': ['ProteinLength', 'Protein Length'],
                 'domainlength':[DomainLengthColumn, 'Domain Length'],
                 'aacomp': ['PercentAminoAcidComposition','Percent Amino Acid Composition'],
                 'deltatango_apr': ['DeltaTango_DensityOfAggProneRegions','Delta Tango (Density of APRs)'],
                 'deltatango_aaapr': ['DeltaTango_DensityOfAAsInAPRs','Delta Tango (Density of AAs in APRs)'],
                 'deltaisd': ['DeltaISD_IUPred2_WithCys', 'Delta ISD']}



    


##########################################################################################
#                                       Submodules                                       #
##########################################################################################



'''

This function will display to the user how to run the program and anything else about this scripts functionality. To access it, use "h" on the command line
'''

def About():
    
    print('\n\n\t\t\t\t\t====================\n\t\t\t\t\t   Metrics Vs Age \n\t\t\t\t\t====================\n\n')
    print('\n\n---------------------------------------------- About ----------------------------------------------\n\n')
    print('Figures\n------------\n\nThis script is designed to generate box and whiskers plots either for full genes or pfam domains metrics vs. time.\nThis is done by collecting all proteins or domains, sorting them either by a homology group ID \nor by pfam ID, taking the average of all data points in a particular grouping, and creating a\ndata frame for all datapoints vs. their age. The data are either then normalized using a box-cox\ntransformation or not (this depends on the user input) and a linear regression is performed.\nThe linear regression and a loess regression are plotted as an overlay on the box and whisker plot\n\nSlope Files\n------------\nIf the user wants to create a csv file that contains the slope(s) and standard error(s) of a particular metric vs time, they can\nus the input option "slopes". For things like ISD, Aggregation Propensity, etc... this will only generate a single row, however,\nif the user is looking at amino acid composition for multiple amino acids, the slopes for all amino acids analyze will be stored\nin the same CSV file.\n\nBoth Options\n------------\nThis script allows the user to enter various options to customize the dataset they are interested in.\nThey may choose the kingdom, the transmembrane status, domains vs. proteins, etc. that they want to analyze.\nAll options are listed for the user below.\n\nNote: order is not important for the command-line arguments')

    print('\n\n---------------------------------------------- Usage ----------------------------------------------\n\n\n')
    print('{:<17}{:<3}{:<100}'.format('Usage',':', 'python3 ScriptName.py pfam|fullgene metric=<x> [test] [speciesuid=<n>] [kingdom=<x>] [transformed]'))
    print('{:<64}{:<3}{:<100}'.format('','', '[transmembrane=<x>] [xlim=<xmin,xmax>] [ylim=ymin,ymax] [aa=<x>]'))
    print('{:<64}{:<3}{:<100}'.format('','', '[slopes] [eukaryotespecific] [lambda[=<x>]')+'\n')

    print('\n\n--------------------------------------------- Options ----------------------------------------------\n\n\n')
    print('{:<18}{:<3}{:<100}'.format('pfam|fullgene',':','(required) pfam or fullgene. Specifies which dataset used to generate slopes\n'))
    print('{:<18}{:<3}{:<100}'.format('metric=<x>',':','(required) Specifies which metric will be plotted\n'))
    print('{:<18}{:<3}{:<100}'.format('test',':','if included, only extracts first 1000 columns from each data table. For use'))
    print('{:<18}{:<3}{:<100}'.format('','','with testing and debugging\n'))

    print('{:<18}{:<3}{:<100}'.format('speciesuid=<n>',':','Amino acid slopes for species with species UID n (found in SpeciesList'))
    print('{:<18}{:<3}{:<100}'.format('','','MySQL table)\n'))

    print('{:<18}{:<3}{:<100}'.format('kingdom=<x>',':','Amino acid slopes for designated kingdom \n'))
    print('{:<18}{:<3}{:<100}'.format('transformed',':','Uses Box-Cox transform to normalize dataset before computing slope'))
    print('{:<18}{:<3}{:<100}'.format('','','By default, if this argument is not included, the data will not be transformed\n'))
    print('{:<18}{:<3}{:<100}'.format('transmembrane=<x>',':','When not included as an argument, all data points are included.'))
    print('{:<18}{:<3}{:<100}'.format('','','When x=true, only includes transmembrane proteins/domains'))
    print('{:<18}{:<3}{:<100}'.format('','','When x=false, only includes proteins/domains predicted to not be transmembrane\n'))


    print('{:<18}{:<3}{:<100}'.format('xlim=<xmin,xmax>',':','configures the x limits of the R plot.\n'))
    print('{:<18}{:<3}{:<100}'.format('ylim=<ymin,ymax>',':','configures the y limits of the R plot.\n'))

    print('{:<18}{:<3}{:<100}'.format('aa=<x>',':','Chooses the amino acid(s) to be analyze. For all amino acids, use "all" or leave'))
    print('{:<18}{:<3}{:<100}'.format('','','blank. Otherwise use a comma-delimited string to select a subset. e.g. aa=V,L,F,M\n'))

    print('{:<18}{:<3}{:<100}'.format('slopes',':','Prints a csv file with linear regression slopes instead of producing a figure\n'))
    
    print('{:<18}{:<3}{:<100}'.format('eukaryotespecific',':','Selects only pfams flagged as eukaryote specific\n'))
    
    print('{:<18}{:<3}{:<100}'.format('lambda[=<x>]',':','Including the argument lambda writes to a file the value used to transform'))
    print('{:<18}{:<3}{:<100}'.format('','','the data. This only works if the user has selected the "slopes" option. If the'))
    print('{:<18}{:<3}{:<100}'.format('','','user includes a value, then the script uses that value to transform the data instead of'))
    print('{:<18}{:<3}{:<100}'.format('','','finding the optimal value.\n\n'))





    print('-------------')
    print('{:<17}{:<3}{:<100}'.format('Domain Options',':','ISD, DensityOfAPRs, DensityOfAAsInAPRs, Clustering_Trunc, Clustering_AllFrames, Length, AAComp\n'))
    print('{:<17}{:<3}{:<100}'.format('Kingdom Options',':','invertebrate, vertebrate, plant, fungi, animal\n\n'))
    print('{:<17}{:<3}{:<100}'.format('Metric Options',':','ISD, DensityOfAPRs, DensityOfAAsInAPRs, Length, AAComp,Clustering_Trunc, Clustering_AllFrames\n\n'))
    
    print('---------------------------------------- Data Transformation ---------------------------------------\n\n\n')
    print("A note about transforming the data:\n\nBecause Box-Cox transforms require values to be greater than zero, if the data are transformed, the value 0.5\nis added to each data point. The reason this is required is because in some cases domains or proteins may be \ntoo short to include all amino acids and so sometimes the percent composition for a particular domain/protein\nhomology group is zero. If a particular metric is dependent on the length of the protein (i.e. Density of APRs\nor AA Composition) 0.5 is added to the numerator. Because the extracted metrics have all been divided by the\nprotein/domain length prior to extraction, this is achieved by adding 0.5\length to the metric\n\n")
    print('------------------------------------------- Dependencies -------------------------------------------\n\n\n')
    print('The user needs to have R installed and will need access to the relevant MySQL databases. \n\nPython dependencies are listed at the beginning of this script and will\nnot be listed here as this script will not run (so this message cannot be seen) without the python dependencies. \n\n\n')
    sys.exit(0)



# -------------------------------------------------------------------------------------------------------------------


'''
This submodule allows us to parse the user's command-line arguments. The arguments are returned to the script so that it can use them to plot the correct data in the right way.

The script will print out the user-arguments in the terminal so the user knows exactly what was selected. If necesary arguments are omitted, the program exits and informs the user


'''

# As input, the function takes the command line arguments and the filename prefix. The filename prefix is the base name that the output
# plot will be saved as and will have additional arguments appended to it based on the user's input preferences
def ParseUserOptions(Arguments,filename_prefix):

    # We break up the command-line arguments and put them in a dictionary so we can easily parse them
    arguments = {}

    for i in Arguments:
        if '=' in i:
            key,argument = i.split('=')
            arguments[key.replace('-','').lower()]=argument.lower()
        else:
            arguments[i.replace('-','').lower()] = True
        
    # If the user has asked for help, the program prints out a user manual to the terminal and exits
    if 'h' in arguments or 'help' in arguments or 'about' in arguments or 'options' in arguments:
        About()

    # Otherwise, the program determines which options are present so it knows how to run
    print('\n\n\n\n##########################################################################################\n#                                     User Options                                       #\n##########################################################################################\n\n\n\n')

    # The user must specify either pfam or fullgene for the program to run, otherwise it doesn't know what it should be extracting
    if 'fullgene' not in arguments and 'pfam' not in arguments:
        print('\n\n\u001b[31mSyntax Error. Either pfam or fullgene must be included in input arguments.\nTo see user options, use the command-line argument "h"\n\n\u001b[0m')
        sys.exit(0)
        
    # If the user has accidentally specified both, then the program exits with a warning
    if 'fullgene' in arguments and 'pfam' in arguments:
        print('\n\n\u001b[31mSyntax Error. Both pfam and fullgene included in input arguments. Cannot extract both.\nTo see user options, use the command-line argument "h"\n\n\u001b[0m')
        sys.exit(0)
    # Otherwise, if the sequence option has been specified correctly, the program continues
    if 'fullgene' in arguments:
        SequenceType = 'fullgene'
        filename_prefix += '_FullGenes'
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mSequence option selected','--','Full genes will be extracted'))
    if 'pfam' in arguments:
        SequenceType = 'pfam'
        filename_prefix += 'PfamOnly'
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mSequence option selected','--','Pfam domains will be extracted'))

    # The user has the option to enter plot limits for r. They should be comma-delimited, otherwise R won't be able to use them
    if 'xlim' in arguments:
        RXLim = arguments['xlim']
    else:
        RXLim = None
    if 'ylim' in arguments:
        RYLim = arguments['ylim']
    else:
        RYLim = None

    # The program must have a metric specified to run, otherwise it exits with an error.
    try:
        Metric = arguments['metric']
        if Metric == 'length' and SequenceType == 'fullgene':
            Metric = 'proteinlength'
        if Metric == 'length' and SequenceType == 'pfam':
            Metric = 'domainlength'
        MetricColumn = MetricOptions[Metric][0]
        MetricLabel = MetricOptions[Metric][1]
        filename_prefix += '_%s'%Metric
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mMetric option selected','--','%s'%MetricLabel))

    except:
        print('\u001b[31mA metric must be specified to generate a plot\nFor help, use option "h"\u001b[0m\n\n')
        sys.exit(0)
        
    # If aa is specified by the user along with the option aacomp, then the amino acids specified are extracted
    if Metric == 'aacomp':
        # If the user doesn't specify particular amino acids, then all are extracted
        try:
            AminoAcidSelection = arguments['aa']
            if AminoAcidSelection == 'all':
                AminoAcidSelection = ['K','R','D','E','Q','S','N','T','P','Y','H','C','G','A','W','V','L','M','F','I']

            elif len(AminoAcidSelection) == 1:
                AminoAcidSelection = [arguments['aa'].replace("'",'').upper()]
            else:
                AminoAcidSelection = [i.upper() for i in AminoAcidSelection.replace("'",'').split(',')]
        except:
            AminoAcidSelection = ['K','R','D','E','Q','S','N','T','P','Y','H','C','G','A','W','V','L','M','F','I']
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mAmino acids selected','--',','.join(AminoAcidSelection)))
    else:
        AminoAcidSelection = [None]
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mAmino acids selected','--','N/A'))


    # It is not necessary to specify a species UID, however, if one is specifed, then only the values for that species
    # are extracted. Any species UID specified will override any kingdom options selected
    try:
        SpeciesUID = arguments['speciesuid']
        filename_prefix += '_SpeciesUID%s'%SpeciesUID
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mSpecies UID Selected : %s'%SpeciesUID,'--','This will override any kingdoms selected'))
    except:
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mNo species UID selected','--','Ignoring specific species'))
        SpeciesUID = None

    # The user has the option to box-cox transform their data prior to analysis. If 'transformed' is not included in the user-arguments,
    # then the analyses are performed on untransformed data
    try:
        Transformed = arguments['transformed']
        filename_prefix += '_BoxCoxTransformed'
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mTransformation Selected','--','Linear models generated with Box-Cox transformed data'))
    except:
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mNo transformation selected','--','Linear models generated by untransformed data'))
        Transformed = False
        filename_prefix += '_NoTransform'

    # The user may select specific kingdoms to analyze as a whole. This can only be used if a species UID hasn't been specified
    try:
        ValidKingdoms = ['plant','invertebrate','vertebrate','fungi','animal']
        Kingdom = arguments['kingdom']
        filename_prefix += '_%s'%Kingdom
        if Kingdom not in ValidKingdoms:
            print('\n\n\u001b[31mInvalid kingdom.\nFor help use input option "h"\n\n\u001b[0m')
            sys.exit(0)

        if SpeciesUID == None:
            print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mKingdom selected','--',Kingdom))
        else:
            print('\n{:<45}{:<5}{:<100}'.format('\u001b[31mKingdom cannot be selected','--','Species UID overrides option'))

    except:
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mNo kingdom selected','--','Including all kingdoms'))
        Kingdom = None
        
    # The user has the further option to break down whichever group they're looking at into transmembrane or non-transmembrane. If this
    # option isn't selected, then no distinction is made
    try:
        Transmembrane = arguments['transmembrane']
        if Transmembrane == 'true':
            print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mTransmembrane option selected','--','Only transmembrane proteins included'))
            Transmembrane = True
            filename_prefix += '_TransmembraneOnly'
        else:
            print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mTransmembrane option selected','--','Only non-transmembrane proteins included'))
            filename_prefix += '_NonTransmembrane'
            Transmembrane = False
    except:
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mNo transmembrane option specified','--','Including entire dataset'))
        Transmembrane = None

    # If 'test' is included on the command line, then only the first thousand sequences are extracted from each table. This cannot be used
    # with kingdom/species UID options
    try:
        Test = arguments['test']

        if Kingdom != None or SpeciesUID != None:
            print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mTest cannot be selected','--','Incompatible with kingdom or species UID specifications'))
            Test = False
        else:
            print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mTest option selected','--','Only extracting first thousand rows from data tables'))
            filename_prefix += '_TEST'
            Test = True
    except:
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mNo Test option selected','--','Extracting full data tables')) 
        Test = False

    # Finally, the user has the option to create a slopes file instead a figures using the input argument "slopes"
    try:
        Slopes = arguments['slopes']
        Slopes = True
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mGenerating slopes file','--','Program will produce a csv file. No figures will be generated.'))

    except:
        Slopes = False
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mGenerating figures','--','Program will produce figure of %s vs. Time. No slope file will be generated'%MetricOptions[Metric][1]))
    try:
        Exit = False
        Lambda = arguments['lambda']
        if Lambda != True:
            try:
                Lambda = float(Lambda)
                print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mLambda value specified','--','Transforming dataset using lambda=%s. Adding Transformed Option.'%Lambda))
                Transformed = True
                

            except:
                print('\n{:<45}{:<5}{:<100}'.format('\u001b[31mInvalid use of lambda','--','Please enter a float or use option "lambda" without "=" to get optimal values\n\n'))
                Exit = True
                sys.exit(0)
        else:
            if Slopes == True and Transformed == True:
                print('\n{:<45}{:<5}{:<100}'.format('\u001b[36;1mLambda specified','--','Writing optimal lambda values to csv file'))
            else:
                print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mLambda option invalid','--','Will only write Lambda to csv file if data are transformed and the argument "slopes" is specified'))
                Lambda = False
    except:
        if Exit == True:
            print('\u001b[0m\n\n')

            sys.exit(0)

        Lambda = False
        print('\n{:<45}{:<5}{:<100}'.format('\u001b[33;1mNo lambda option specified','',''))
    try:
        EukaryoteSpecific = arguments['eukaryotespecific']
    except:
        EukaryoteSpecific = False

                


    print('\u001b[0m\n\n')
    print('\n\n\n##########################################################################################\n\n\n\n')
    return SequenceType,SpeciesUID,Transformed,Kingdom,Transmembrane,Test,Metric,AminoAcidSelection,filename_prefix,RXLim,RYLim,Slopes,Lambda,EukaryoteSpecific


# -------------------------------------------------------------------------------------------------------------------


'''
The program requires somewhat complicated MySQL extraction statements since the pfam and protein metric data can be stored in a number of connected tables
As a consequence, there is a function dedicated to creating the extraction statements so that the data will be extracted in a systematic way.

The reason these statements are particularly complicated is because of this script's customizability. If we want to only extract data from transmembrane proteins,
a particular species, a particular kingdom, or want to only test the script, we need a modified extraction statement. It is also contingent on which metric we're
# extracting
'''

def ConfigureExtractionStatement(SequenceType,Kingdom,SpeciesUID,Test,Metric,EukaryoteSpecific):
    # Ensembl and NCBI tables each need their own extraction statements
    DataTables = {'Ensembl':
                  {'Protein Table':EnsemblProteinDataTable,'Pfam Table':EnsemblPfamDataTable,'Unique Table':EnsemblUniqueProteinTable,'Extraction Statement':'','Type':''},
                'NCBI':
                  {'Protein Table':NCBIProteinDataTable,'Pfam Table':NCBIPfamDataTable,'Unique Table':NCBIUniqueProteinTable,'Extraction Statement':'','Type':''}}
    
    # Full genes and pfam domains are stored in their own tables, so we need to build base extraction statements
    # that are based on which we're extracting from
    if SequenceType == 'fullgene':
        for dataTable in DataTables:
            
            proteinTable = DataTables[dataTable]['Protein Table']
            uniqueTable = DataTables[dataTable]['Unique Table']

            MetricColumn = MetricOptions[Metric][0]
            # The base extraction statement pulls the required information to perform our analyses. 
            BaseExtractionStatement = "SELECT "+','.join(['%s.%s'%(proteinTable,AgeColumn),'%s.%s'%(proteinTable,MetricColumn),'%s.%s'%(proteinTable,FilterColumn),'%s.%s'%(proteinTable,HomologyGroupIDColumn),'%s.%s'%(proteinTable,TransmembraneColumn),'%s.%s'%(proteinTable,ProteinLengthColumn)])+" FROM " + proteinTable + " INNER JOIN " + uniqueTable + " ON %s.%s=%s.%s"%(proteinTable,UIDColumn,uniqueTable,UniqueProteinTableUID)
            DataTables[dataTable]['Extraction Statement'] = BaseExtractionStatement
            # We store whether this extraction statement is for pfams or full proteins. This determines how we will customize it
            DataTables[dataTable]['Type'] = 'Protein Table'

    # The same process is performed on pfam domains
    elif SequenceType == 'pfam':
        for dataTable in DataTables:
            
            pfamDataTable = DataTables[dataTable]['Pfam Table']
            proteinDataTable = DataTables[dataTable]['Protein Table']
            uniqueTable = DataTables[dataTable]['Unique Table']

            MetricColumn = MetricOptions[Metric][0]
            
            BaseExtractionStatement = "SELECT %s.%s,"%(PfamUIDTable,PfamAgeColumn)+"%s.%s,"%(pfamDataTable,MetricColumn)+"%s.%s,"%(pfamDataTable,PfamDataTableFilterColumn)+'%s.%s,'%(pfamDataTable,PfamDataTablePfamUIDColumn)+"%s.%s,"%(pfamDataTable,DomainTransmembraneColumn)+"%s.%s"%(pfamDataTable,DomainLengthColumn)+" FROM "+pfamDataTable+" LEFT JOIN "+PfamUIDTable+" ON %s.%s=%s.%s"%(pfamDataTable,PfamDataTablePfamUIDColumn,PfamUIDTable,PfamUIDColumn)+ " INNER JOIN "+uniqueTable + " ON %s.%s=%s.%s"%(pfamDataTable,PfamDataTableProteinUIDColumn,uniqueTable,UniqueProteinTableUID)
            DataTables[dataTable]['Extraction Statement'] = BaseExtractionStatement
            DataTables[dataTable]['Type'] = 'Pfam Table'


    # Now customization can take place
    for dataTable in DataTables:
        TableDesignation = DataTables[dataTable]['Type']

        # If only one species is desired, we change our extraction statement so only that species is pulled
        if SpeciesUID != None:
            if TableDesignation == 'Protein Table':
                proteinTable = DataTables[dataTable][TableDesignation]
                DataTables[dataTable]['Extraction Statement'] += " WHERE %s.%s"%(proteinTable,FullGeneSpeciesUIDColumn)+" = " +str(SpeciesUID)
            else:
                pfamDataTable = DataTables[dataTable][TableDesignation]
                DataTables[dataTable]['Extraction Statement'] += " WHERE %s.%s"%(pfamDataTable,PfamSpeciesUIDColumn) + " = "+str(SpeciesUID)
        # If a particular kingdom is desired, we only pull species from that kingdom
        elif Kingdom != None:
            if TableDesignation == 'Protein Table':
                if Kingdom != 'animal':
                    proteinTable = DataTables[dataTable][TableDesignation]
                    DataTables[dataTable]['Extraction Statement'] += " LEFT JOIN "+SpeciesTable+" ON %s.%s=%s.%s"%(SpeciesTable,SpeciesUIDColumn,proteinTable,FullGeneSpeciesUIDColumn) + " WHERE %s.%s"%(SpeciesTable,KingdomColumn) + " ='%s'"%Kingdom
                else:
                    proteinTable = DataTables[dataTable][TableDesignation]
                    DataTables[dataTable]['Extraction Statement'] += " LEFT JOIN "+SpeciesTable+" ON %s.%s=%s.%s"%(SpeciesTable,SpeciesUIDColumn,proteinTable,FullGeneSpeciesUIDColumn) + " WHERE %s.%s"%(SpeciesTable,KingdomColumn) + " ='invertebrate' OR %s.%s"%(SpeciesTable,KingdomColumn) + "='vertebrate'"
            else:
                if Kingdom != 'animal':
                    pfamDataTable = DataTables[dataTable][TableDesignation]
                    DataTables[dataTable]['Extraction Statement'] += " LEFT JOIN "+SpeciesTable+" ON %s.%s=%s.%s"%(SpeciesTable,SpeciesUIDColumn,pfamDataTable,PfamSpeciesUIDColumn) + " WHERE %s.%s"%(SpeciesTable,KingdomColumn) + " ='%s'"%Kingdom
                else:
                    pfamDataTable = DataTables[dataTable][TableDesignation]
                    DataTables[dataTable]['Extraction Statement'] += " LEFT JOIN "+SpeciesTable+" ON %s.%s=%s.%s"%(SpeciesTable,SpeciesUIDColumn,pfamDataTable,PfamSpeciesUIDColumn) + " WHERE %s.%s"%(SpeciesTable,KingdomColumn) + " ='invertebrate' OR %s.%s"%(SpeciesTable,KingdomColumn) +"='vertebrate'"
        # If Test is specified, then we only pull the first thousand rows from each data table
        elif Test != False:
            if TableDesignation == 'Protein Table':
                proteinTable = DataTables[dataTable][TableDesignation]
                DataTables[dataTable]['Extraction Statement'] += " WHERE %s.%s"%(proteinTable,UIDColumn) + " <1000"
            else:
                pfamDataTable = DataTables[dataTable][TableDesignation]
                DataTables[dataTable]['Extraction Statement'] += " WHERE %s.%s"%(pfamDataTable,PfamDataTableUIDColumn)+" <1000"

        # If the user has specified they only want eukaryote specific pfams, then only those that are flagged as such
        # in the pfam table are pulled from the relevant tables using a where statement
        if EukaryoteSpecific == True and TableDesignation != 'Protein Table':
            if 'WHERE' in DataTables[dataTable]['Extraction Statement']:
                DataTables[dataTable]['Extraction Statement'] += " AND %s.%s"%(PfamUIDTable,EukaryoteSpecificColumn) +"='True'"
            else:
                DataTables[dataTable]['Extraction Statement'] += " WHERE %s.%s"%(PfamUIDTable,EukaryoteSpecificColumn) +"='True'"

    # And we return the customized extraction statements to the user. There will be two of them, one for NCBI, one for Ensembl
    return [DataTables[i]['Extraction Statement'] for i in DataTables]



# -------------------------------------------------------------------------------------------------------------------


# We create a Homology dictionary so that we can average metrics over either pfam domains or proteins in the same homology group
def CreateHomologyDictionary(MySQLResults,Transmembrane,Transformed,MetricOption):

    HomologyDictionary = {}

    for result in MySQLResults:
        Age,Metric,Filter,HomologyGroupID,ExpAA,Length = result
        AminoAcids = ['A','R','N','D','C','E','Q','G','H','O','I','L','K','M','F','P','U','S','T','W','Y','V']
        # We make sure we can parse the data appropriately
        if result != None and Metric != None and int(Filter) != int(False) and int(Length) > 0:
            # And make the correct transmembrane choice
            if (Transmembrane == True and ExpAA != None and ExpAA > 18) or (Transmembrane == False and ExpAA != None and ExpAA <= 18) or Transmembrane == None or (Transmembrane == False and ExpAA != None and ExpAA <TransmembraneThresholdCutoff) or (Transmembrane == True and ExpAA != None and ExpAA >= TransmembraneThresholdCutoff):
                # If we're looking at amino acid compositions, then we need a slightly different dictionary that contains
                # the values for each amino acid stored in the tables, which are stored as comma-delimited strings
                if MetricOption == 'aacomp':
                    AAComposition = [float(j) for j in result[1].split(',')]
                    if HomologyGroupID not in HomologyDictionary:
                        # The age of each group is stored 
                        HomologyDictionary[HomologyGroupID] = {'Age':Age}
                        for i in range(0,len(AminoAcids)):
                            HomologyDictionary[HomologyGroupID][AminoAcids[i]] = [AAComposition[i]]
                    # Once the homology group ID has been stored in the dictionary, we start adding values
                    # to the preexisting lists
                    else:
                        for i in range(0,len(AminoAcids)):
                            HomologyDictionary[HomologyGroupID][AminoAcids[i]].append(AAComposition[i])
                # The dictionary is simpler if we're looking at metrics with single values. It's the same basic
                # principle, except instead of saving an entry for each amino acid, we only save one list for
                # that one metric
                else:
                    if HomologyGroupID not in HomologyDictionary:
                        HomologyDictionary[HomologyGroupID] = {'Age':Age}
                        if Transformed == True:
                            if MetricOption == 'densityofaprs' or MetricOption == 'densityofaasinaprs':
                                Metric += (0.5/Length)
                            else:
                                Metric += 0.5
                            HomologyDictionary[HomologyGroupID]['Metric'] = [Metric]
                        else:
                            HomologyDictionary[HomologyGroupID]['Metric'] = [Metric]
                    else:
                        if Transformed == True:
                            if MetricOption == 'densityofaprs' or MetricOption == 'densityofaasinaprs':
                                Metric += (0.5/Length)
                            else:
                                Metric += 0.5
                            HomologyDictionary[HomologyGroupID]['Metric'].append(Metric)
                        else:  
                            HomologyDictionary[HomologyGroupID]['Metric'].append(Metric)
    return HomologyDictionary


# -------------------------------------------------------------------------------------------------------------------


'''
This function allows the user to generate a pdf plot in R. The command Rscript is necessary to run

'''


def PlotInR(HomologyDictionary,Transformed,Metric,filename,RXLim,RYLim,AminoAcid,Lambda):

    # A temporary file is created for R to read. There is a row for each homology group (pfam or full protein)
    # with the average metric score associated with that homology group and the age of that homology group
    TempDataFrameFilename = 'TempDataFrame.csv'
    DataFrameForR = open(TempDataFrameFilename,'w')
    DataFrameForR.write('Metric,Age\n')

    for HomologyGroupID in HomologyDictionary:

        # If we're not looking at amino acid composition as our metric, then we pull the single metric available
        # for the homology group we're considering by averaging over all values of that metric associated with that
        # homology group ID. 
        if AminoAcid == None:
            MeanHomologyGroupMetric = np.mean([float(i) for i in HomologyDictionary[HomologyGroupID]['Metric']])

        # If we're considering amino acid composition, then we pull the fractional scores associated with that particular
        # amino acid from the homology group dictionary. This function is designed to be run on one amino acid at a time, so
        # only the specified amino acid (input = AminoAcid) is selected for analysis
        else:
            MeanHomologyGroupMetric = np.mean(HomologyDictionary[HomologyGroupID][AminoAcid])
        # We then write the age of that homology group into the dataframe
        Age = HomologyDictionary[HomologyGroupID]['Age']
        if Age != None and MeanHomologyGroupMetric != None:
            DataFrameForR.write('%s,%s\n'%(MeanHomologyGroupMetric,Age))
    DataFrameForR.close()
    
    # Once the dataframe is assembled, we need to write an R script to run a linear model on the data
    RScriptFilename = 'TempRScript.r'
    RScript = open(RScriptFilename,'w')
    RScript.write('library(MASS)\n')
    # The R script reads in our dataframe
    RScript.write('df <- read.csv(file = "%s",header = T)\n'%TempDataFrameFilename)
    # We then attach the dataframe and order based on age so that we can perform a loess regression
    RScript.write('attach(df)\n')
    RScript.write('df <- df[order(Age),]\n')
    # If the user wants to transform their data prior to running a linear model, we create a box-cox
    # transformation function and add an additional column to our dataframe that contains all the transformed
    # values
    if Transformed == True:

        # Our various possible transformations are defined
        # For most metrics, we transform using a box-cox transform
        RScript.write('bc.transform <- function(x,L){(x^L-1)/L}\n')
        RScript.write('bc.backtransform <- function(y,L){(L*y+1)^(1/L)}\n')
        # The exception is when we're dealing with frequency data, specifically the percent AA composition
        # values. In that case we use an arcsine transform
        RScript.write('asin.transform <- function(x){asin(sqrt(x))}\n')
        if Metric == 'aacomp':
            RScript.write('Metric.transform <- asin.transform(df$Metric)\n')
        else:
            RScript.write('bc <- boxcox(df$Metric~1, lambda = seq(.1,.7,0.01))\n')
            # The script selects the optimal value to transform the data with
            if type(Lambda) == float:
                RScript.write('lambda <- %s\n'%Lambda)
            else:
                RScript.write('lambda <- bc$x[which.max(bc$y)]\n')
            RScript.write('Metric.transform <- bc.transform(df$Metric,lambda)\n')
        RScript.write('df$Metric.transform<-Metric.transform\n')
        RScript.write('loessMod10 <- loess(df$Metric.transform~df$Age,span=1)\nsmoothed10 <- predict(loessMod10)\n')
        # And a linear regression is performed on the transformed data
        RScript.write('SimpleLinearModel <- lm(df$Metric.transform ~ df$Age)\n')
        # We then save our columns so we can plot them later 
        RScript.write('X <- df$Age\nY <- df$Metric.transform\n')

    else:
        # If the user doesn't want to transform their data, then no box-cox work needs to be done and we
        # simply perform a linear regression on the input data
        RScript.write('loessMod10 <- loess(df$Metric~df$Age,span=1)\nsmoothed10 <- predict(loessMod10)\n')
        RScript.write('SimpleLinearModel <- lm(df$Metric ~ df$Age)\n')
        RScript.write('X <- df$Age\nY <- df$Metric\n')

    # We then pull the intercept and slope from the linear model so we can plot the linear regression over
    # the generated box and whiskers plot 
    RScript.write('Intercept <- coef(SimpleLinearModel)["(Intercept)"]\n')
    RScript.write('Slope <- coef(SimpleLinearModel)["df$Age"]\n')
    # We will also extract the pvalue and format it as a string. Each plot will have the pvalue associated with the linear
    # regression as the title
    RScript.write('Pvalue <- summary(SimpleLinearModel)$coefficients[,4]  \n')
    RScript.write('pvalueString <- paste(c("P=",signif(Pvalue,digits=2)[2]),sep = "",collapse="")\n')
    RScript.write('Title <- pvalueString\n')
    
    # We save the plot as a pdf with the filename that has been customized by the user options
    RScript.write('pdf("%s",width=10)\n'%filename)
    # Sometimes the margins can get a little too tight, particularly if the label sizes have been increased, so we adjust them
    # so everything fits
    RScript.write('par(mar=c(5,4.5,3,1))\n')
    
    # We generate the plot so that we can add all of our data onto it (things can get messed up if the plot is not generated first,
    # specifically some weirdness with the axes and the clustering of box and whiskers plots). We let the x- and y-limits autogenerate
    # unless the user has specified specific limits in the input of this script. If custom limits have been specified, we add them
    PlotString = 'plot(X,Y,type="n",main=Title,xlab="Age (millions of years)",ylab="%s",cex.lab=1.75,col="dodgerblue",pch=20,cex.axis=1.75,cex.main=1.7'%MetricOptions[Metric][1]
    if RXLim != None:
        PlotString += ',xlim=c(%s)'%RXLim
    if RYLim != None:
        PlotString += ',ylim=c(%s)'%RYLim
    PlotString += ')\n'
    RScript.write(PlotString)

    # Once the plot background has been generated, we add the box and whiskers plot
    RScript.write('boxplot(Y~X,add=TRUE,at=c(unique(df$Age)), boxfill = "lightblue",main="",xlab="",ylab="",xaxt="n",yaxt="n",position="dodge",pch=".",varwidth=TRUE,boxwex=20)\n')
    # We then add the linear and loess regressions
    RScript.write('abline(Intercept,Slope,lwd=4)\n')
    RScript.write('lines(smoothed10,x=X,col="darkslategray4",lwd=4)\n')

    # And add the legend. Adding usr allows us to standardize the placement of the legend within the body of the plot
    RScript.write('usr <- par( "usr" )\n')
    RScript.write('legend( usr[ 2 ]-(usr[2]*.45),usr[ 4 ]-(.05*usr[4]),legend=c("Linear Regression","Loess Regression"),col=c("black","darkslategray4"),lty=1:1,cex=1.4,lwd=3)\n')

    # Closes the PDF figure
    RScript.write('dev.off()\n')
    RScript.write('head(df)')
    RScript.close()

    # Once our R script has been written, we run it and remove any unwanted files
    ROutputFilename = 'R.out'
    # If the user wants to see every command being run, including what's going on with R, they can set VeryVerbose to True. Otherwise,
    # the output from R is directed to a junk file and disposed of.
    if VeryVerbose == True:
        os.system('%s %s'%(RunRCommand,RScriptFilename))
    else:
        os.system('%s %s &>%s'%(RunRCommand,RScriptFilename,ROutputFilename))
    UnwantedFiles = [RScriptFilename, TempDataFrameFilename,'Rplots.pdf',ROutputFilename]
    for unwantedFile in UnwantedFiles:
        if os.path.exists(unwantedFile) == True:
            os.remove(unwantedFile)


# -------------------------------------------------------------------------------------------------------------------


'''
This function is used to generate a csv file that contains the slopes and standard errors for a metric vs. age. This function 
opens a file with the append function and adds to it if more than one metric is being examined in a single run. In particular, 
if multiple amino acid slopes are being found 

'''
def GenerateSlopesFile(HomologyDictionary,Transformed,Metric,filename,AminoAcid,Lambda):
    AminoAcidSlopesFile = open(filename,'a')
    # If the file is empty, then it needs a header. Otherwise, only the raw data will be added
    if os.stat(filename).st_size ==0:
        if Lambda != True:
            AminoAcidSlopesFile.write('AminoAcid,Slope,Error\n')
        else:
            AminoAcidSlopesFile.write('AminoAcid,Slope,Error,OptimalLambda,MinLambdaConfidence,MaxLambdaConfidence\n')
    # A temporary dataframe needs to be created so R can read it in
    TempDataFrameFilename = 'TempDataFrame.csv'
    DataFrameForR = open(TempDataFrameFilename,'w')
    DataFrameForR.write('Metric,Age\n')
    for HomologyGroupID in HomologyDictionary:
        # Whether we're choosing an amino acid or another form of metric determines how we select our metric
        # values from the homology dictionary
        if AminoAcid == None:
            MeanHomologyGroupMetric = np.mean(HomologyDictionary[HomologyGroupID]['Metric'])
        else:
            MeanHomologyGroupMetric = np.mean(HomologyDictionary[HomologyGroupID][AminoAcid])
        Age = HomologyDictionary[HomologyGroupID]['Age']
        if Age != None and MeanHomologyGroupMetric != None:
            DataFrameForR.write('%s,%s\n'%(MeanHomologyGroupMetric,Age))
    DataFrameForR.close()
    
    # We then need to write an R script so we can perform the necessary linear regressions
    RScriptFilename = 'TempRScript.r'
    RScript = open(RScriptFilename,'w')
    
    # R starts by reading in the dataframe
    RScript.write('df <- read.csv(file = "%s",header = T)\n'%TempDataFrameFilename)
    RScript.write('library(MASS)\n')
    # If a transformation is desired, then R box-cox transforms the data and perfoms a linear regression. Otherwise,
    # a linear regression is performed on untransformed data
    if Transformed == True:

        RScript.write('bc.transform <- function(x,L){(x^L-1)/L}\n')
        RScript.write('bc.backtransform <- function(y,L){(L*y+1)^(1/L)}\n')
        RScript.write('asin.transform <- function(x){asin(sqrt(x))}\n')
        if Metric == 'aacomp':
            RScript.write('Metric.transform <- asin.transform(df$Metric)\n')
        else:
            RScript.write('bc <- boxcox(df$Metric~1, lambda = seq(.1,.7,0.01))\n')
            if type(Lambda) == float:
                RScript.write('lambda <- %s\n'%Lambda)
            else:
                RScript.write('lambda <- bc$x[which.max(bc$y)]\n')
                RScript.write('lambdaInterval <- range(bc$x[bc$y > max(bc$y) -1/2*qchisq(.95,1)])\n')
            if Lambda == True:
                RScript.write('sprintf("%s %s %s",lambda , min(lambdaInterval), max(lambdaInterval))\n')
            RScript.write('Metric.transform <- bc.transform(df$Metric,lambda)\n')
        RScript.write('df$Metric.transform<-Metric.transform\n')
        RScript.write('SimpleLinearModel <- lm(df$Metric.transform ~ df$Age)\n')
        RScript.write('summary(SimpleLinearModel)')
    else:
        RScript.write('SimpleLinearModel <- lm(df$Metric ~ df$Age)\n')
        RScript.write('summary(SimpleLinearModel)')

    RScript.close()
        
    ROutputFilename = 'R.out'
    # R is then run on the script using the temporary dataframe and the output is saved to a temporary file
    os.system('%s %s>%s'%(RunRCommand,RScriptFilename,ROutputFilename))
    # The slope and standard errors are then read from the temporary file and saved to the user's csv file
    with open(ROutputFilename,'r') as f:
        reader = csv.reader(f)
        for row in reader:
            if len(row) != 0:
                rowContents = [i for i in row[0].split(' ') if i != '']
                if rowContents[0] == '[1]':
                    OptimalLambda, MinLambda, MaxLambda = ['%.2f'%float(i.replace('"','')) for i in rowContents[1:4]]
                if rowContents[0] == 'df$Age':
                    Slope, Error = rowContents[1:3]
                    if Lambda == True:
                        AminoAcidSlopesFile.write('%s,%s,%s,%s,%s,%s\n'%(AminoAcid,Slope,Error,OptimalLambda,MinLambda,MaxLambda))
                    else:
                        AminoAcidSlopesFile.write('%s,%s,%s\n'%(AminoAcid,Slope,Error))
    AminoAcidSlopesFile.close()
    # The program then cleans up after itself
    UnwantedFiles = [ROutputFilename,RScriptFilename,TempDataFrameFilename,'Rplots.pdf']
    for unwantedFile in UnwantedFiles:
        if os.path.exists(unwantedFile) == True:
            os.remove(unwantedFile)
            
                    


##########################################################################################
#                                Program Executes Below                                  #
##########################################################################################




start_time = datetime.datetime.now()
print('\n\nProgram Starting\nCurrent Time: %s'%start_time)
cnx = mysql.connector.connect(user = User,
                              password = Password,
                              host = Host,
                              database = Database)
mycursor = cnx.cursor(buffered = True)

# The script will generate either a plot or a slope file with a customized name based on the user input
filename_prefix = 'MetricVsTime'

# The user's input is parsed so the program knows how to run
SequenceType,SpeciesUID,Transformed,Kingdom,Transmembrane,Test,Metric,AminoAcidSelection,filename,RXLim,RYLim,Slopes,Lambda,EukaryoteSpecific = ParseUserOptions(sys.argv[1:],filename_prefix)



# The MySQL extraction statements are somewhat complicated so they are generated systematically with their own
# function
extractionStatements = ConfigureExtractionStatement(SequenceType,Kingdom,SpeciesUID,Test,Metric,EukaryoteSpecific)



# We need to extract our data from multiple databases, so we'll store results all extracted results
if Verbose == True:
    print('Extracting data from MySQL databases\n')
extractionResults = []
for extraction in extractionStatements:
    mycursor.execute(extraction)
    extractionResults += mycursor.fetchall()
if Verbose == True:
    print('Data successfully extracted\nTime Taken: %s\n\nCreating Homology Dictionary\n'%(datetime.datetime.now()-start_time))
    intermediate_time = datetime.datetime.now()

# We then need to construct a homology dictionary which groups metrics by eith pfam ID or full protein homology group ID
HomologyDictionary = CreateHomologyDictionary(extractionResults,Transmembrane,Transformed,Metric)
if Verbose == True:
    print('Homology Dictionary Successfully Created\nTime Taken: %s\n'%(datetime.datetime.now()-intermediate_time))
    intermediate_time = datetime.datetime.now()

# Since generating a CSV file for the amino acid slopes uses the append function (so it's compatible with a for-loop
# allowing it to write multiple amino acids to the same file), we delete any preexisting csv files with the same name
# so we can generate clean files each run. 
if Slopes == True:
    filename += '.csv'
    if os.path.exists(filename) == True:
        os.remove(filename)
        time.sleep(.1)
    
# We then generate as many slopes or figures as there are in our dataset >= 1
for AA in AminoAcidSelection:
    # If slopes is set to false, we generate figures
    if Slopes == False:
        if Verbose == True:
            if AA != None:
                print('Creating Plot for Amino Acid %s'%AA)
            else:
                print('Creating Plot')
                
        FinalFilename = filename + '_%s.pdf'%AA
        PlotInR(HomologyDictionary,Transformed,Metric,FinalFilename,RXLim,RYLim,AA,Lambda)
    # If slopes is True, then we generate a csv file with the slopes and standard errors of the metrics we're investigating
    else:
        GenerateSlopesFile(HomologyDictionary,Transformed,Metric,filename,AA,Lambda)
        
print('Script Complete!\nTime Taken: %s'%(datetime.datetime.now()-start_time))
