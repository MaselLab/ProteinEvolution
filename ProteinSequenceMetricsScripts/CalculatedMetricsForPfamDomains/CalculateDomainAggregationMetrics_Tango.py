import csv, os, sys, json, mysql.connector, time, datetime
from multiprocessing import Pool, Process
from Bio import SeqIO
from Bio.Seq import Seq

'''
This script is intended to pull preexisiting raw Tango scores from a full-protein run from a MySQL data table and to find various aggregation metrics for the pfam domains associated with that protein sequence. The results will then be uploaded to a user-specified MySQL data table. 

To use this script, there Tango scores should be stored in a database with comma-delimited strings of pfams IDs, their starting and stopping indices, and a list of UIDs associated with those pfam domains in a domain data table

NOTE: 
-----
The UIDs for the tables in question should be integers, otherwise this script will exit with an error

'''

# User-Specific Information
################################################################################


# User's information access the MySQL database
Database = '' 
User = ''
Host = ''
Password = ''
ProteinDataTable = ''
DomainMetricsDataTable = ''

# Tango-specific scores
AggregationThreshold = 5 # Min Tango score to be considered prone to aggregation
RunThreshold = 6 # Minimum run length to be considered an APR




# Submodules
################################################################################

'''
The following submodule is used to find aggregation-prone regions in a list of raw Tango output scores.

Input:
   1) AggregationList -- This is the list of raw Tango scores
   2) AggThreshold -- This the minimum tango AA-specific score that's counted as aggregation prone
   3) RunThreshold -- This is the minimum length of a run to be considered an APR

Output: 
A list of lists; each sublist is the string of raw scores comprising an APR
'''

def FindAPRs(AggregationList, AggThreshold, RunThreshold):
    run = []
    runs = []
    for aggValue in AggregationList:
        # We allow X's to be included in a run in case they are at the tail ends. We later check
        # to remove runs that contain an X in the body of the sequence
        if (type(aggValue) == float and float(aggValue) > AggThreshold) or aggValue == 'X':
            run.append(aggValue)
        else:
            # as soon as a run ends, we check to see whether the ends contain X's.
            # If so, we trim the sequence so it no longer contains the unknown ends.
            if len(run) >= RunThreshold:
                if run[0:2] == 'XX':
                    run = run[2:]
                if run[0] == 'X':
                    run = run[1:]
                if run[-2:] == 'XX':
                    run = run[:-2]
                if run[-1:] == 'X':
                    run = run[:-1]
                # Once the X's are removed from the ends, we check to see if the length still
                # exceeds the run length threshold. If so, we make sure there are no unknown
                # residues in the run. If there are, the run is discarded, otherwise we add
                # the run to the master list
                if len(run) >= RunThreshold:
                    if 'X' in run:
                        run = []
                    else:
                        runs.append(run)
                        run = []
                else:
                    run = []
    if run == []:
        return False
    else:
        return runs

'''
This is used to determine aggregation metrics for a pfam domain. The metrics included

   1) Number of amino acids in an aggregation prone region
   2) The density of amino acids in an aggregation prone region
   3) The number of aggregation prone regions in that domain
   4) The density of aggregation prone regions

The function takes three arguments as input

   1) AggregationList -- this is the list of raw Tango scores
   2) AggregationRuns -- The list of lists of APRs generated by the submodule FindAPRs
   3) pfam -- This should be a tuple of the domain indices being searched: (startIndex,stopIndex)
'''

def CalculatePfamAggregation(AggregationList, AggregationRuns, pfam):

    numOfAAsInAPRs = 0
    numberOfRegions = 0
    for run in AggregationRuns:
        lengthOfRun = len(run)
        # We locate each list of scores from an APR within the master Aggregation score list, getting
        # the starting index of the APR in return
        for ind in (i for i,e in enumerate(AggregationList) if e == run[0]):
            if AggregationList[ind:ind+lengthOfRun]:
                # We get the starting/stopping indices of the APR so we can see if they overlap with
                # the pfam domain
                startIndex = ind
                stopIndex = ind + lengthOfRun
        # We check to see if there's overlap beteen the APR and the specific Pfam being searched
        Intersection = set(range(pfam[0],pfam[1]+1)).intersection(set(range(startIndex, stopIndex+1)))
        # If there's no overlap, the run doesn't matter and we move on
        if len(Intersection) == 0:
            pass
        # If there is overlap, then the pfam has an APR and we determine the relevant metrics
        else:
            numOfAAsInAPRs += len(Intersection)
            numberOfRegions += 1
    numOfAAsInAPRs_Density = numOfAAsInAPRs/(pfam[1]-pfam[0])
    numOfAggProneRegions_Density =numberOfRegions/(pfam[1]-pfam[0])

    return numOfAAsInAPRs, numOfAAsInAPRs_Density, numberOfRegions, numOfAggProneRegions_Density

################################################################################


# Program Executes Below
################################################################################

start_time = datetime.datetime.now()
# We establish a connection to the MySQL database where all our data are stored
cnx = mysql.connector.connect(user = User,
                              password = Password,
                              host = Host,
                              database = Database)
mycursor = cnx.cursor(buffered = True)
# This is why the UID needs to be an integer. Because some of the tables used in this analysis can be gigantic, it
# speeds the process up considerably if we pull one sequence at a time as opposed to trying to pull the entire
# datatable in one go
ExtractionStatement = "SELECT Max(UID) FROM "+ProteinDataTable
mycursor.execute(ExtractionStatement)
MaxUID = mycursor.fetchone()[0]
for i in range(1, MaxUID+1):
    DomainExtractionStatement = "SELECT UID,PfamUID,PfamStart,PfamStop,PfamMetricsTableUID,RawTangoOutputScores FROM " + ProteinDataTable + " WHERE UID = %s"%i
    mycursor.execute(DomainExtractionStatement)
    result = mycursor.fetchone()
    if result != None:
        UID = result[0]
        # We convert all our comma-delimited strings containing pfam data into lists with the correct variable types
        PfamUID = result[1].split(',')
        PfamStart = [int(j) for j in result[2].split(',')]
        PfamStop = [int(j) for j in result[3].split(',')]
        PfamMetricsTableUID = [int(j) for j in result[4].split(',')]
        RawTangoOutputScores = result[5]
        # Sometimes the list of tango scores will be empty for a number of reasons, primarily because the full protein sequence didn't pass
        # a particular filter, e.g. it was too long or contained too many unknown residues
        if RawTangoOutputScores == 'NULL':
            pass
        else:
            RawTangoOutputScores= [float(j) for j in result[5].split(',') if j!='X']
            # We need to know what the aggregation prone regions are before we can consider pfams
            AggregationProneRegions = FindAPRs(RawTangoOutputScores, AggregationThreshold, RunThreshold)
            if AggregationProneRegions == False:
                for j in range(0,len(PfamUID)):
                    updateStatement = "UPDATE " + DomainMetricsDataTable + " SET NumOfAPRs=%s,DensityOfAggProneRegions=%s,NumberOfAAsInAPRs=%s,DensityOfAAsInAPRs=%s WHERE UID = %s"
                    updateValues = (0,0,0,0,PfamMetricsTableUID[j])
                    mycursor.execute(updateStatement,updateValues)
                    cnx.commit()
            else:
                for j in range(0,len(PfamUID)):
                    Start = PfamStart[j]
                    Stop = PfamStop[j]
                    pfamIndices = (Start,Stop)
                    numOfAAsInAPRs, numOfAAsInAPRs_Density,numOfAggProneRegions,numOfAggProneRegions_Density = CalculatePfamAggregation(RawTangoOutputScores,AggregationProneRegions,pfamIndices)
                    updateStatement = "UPDATE "+ DomainMetricsDataTable +" SET NumOfAPRs=%s,DensityOfAggProneRegions=%s,NumberOfAAsInAPRs=%s,DensityOfAAsInAPRs=%s WHERE UID = %s"
                    updateValues = (numOfAggProneRegions,numOfAggProneRegions_Density,numOfAAsInAPRs,numOfAAsInAPRs_Density,PfamMetricsTableUID[j])
                    mycursor.execute(updateStatement,updateValues)
                    cnx.commit()

print('Analysis Complete\nTime Taken: %s' %(datetime.datetime.now()-start_time))
cnx.close()
        
